Enjoy solving problems!

Just like gaming!

## Sorted Array

- Binary Search
- Two Pointers

## Binary Search tree

- converted to sorted array

## Permutations/Subsets

- Backtracking
  - cache intermediate results

## Tree

- BFS
- DFS

  - find recursion pattern
  - compare tree/subtree -> match string/sub-string
  - try **in-place** if building a new tree from another tree

- traversal from the TARGET node if the relation is about the TARGET node

- tree sum

  1. decrease from top to bottom
  2. increase from top to bottom

- bottom-up if result rely on children selection

- will the DFS pattern affect other branches (sub-problems)?
- will the intermediate result of DFS is enough to solve the sub-problem?
  - for example, the current intermediate result may rely on the result of another sub-problem

1. understand the problem
2. construct the pattern
3. relation between sub-problems (between current node, its siblings and ancestors)

## Graph

- BFS
- DFS

## Linked List

- Two Pointers

## No Recursion

- Stack

## In-place

- Swap
- Store different values in the same pointer

## Top K

- Heap
- QuickSelect

## Common Strings

- Map
- Trie

## General Approach

- Map/Set for O(1) time & O(n) space
- Sort input for O(nlogn) time and O(1) space
